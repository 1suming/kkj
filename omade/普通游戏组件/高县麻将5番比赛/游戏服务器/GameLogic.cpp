#include "StdAfx.h"
#include "GameLogic.h"
#include "math.h"


//////////////////////////////////////////////////////////////////////////

//静态变量
bool		CChiHuRight::m_bInit = false;
DWORD		CChiHuRight::m_dwRightMask[MAX_RIGHT_COUNT];

//构造函数
CChiHuRight::CChiHuRight()
{
	ZeroMemory( m_dwRight,sizeof(m_dwRight) );

	if( !m_bInit )
	{
		m_bInit = true;
		for( BYTE i = 0; i < CountArray(m_dwRightMask); i++ )
		{
			if( 0 == i )
				m_dwRightMask[i] = 0;
			else
				m_dwRightMask[i] = (DWORD(pow(2.0,i-1)))<<28;
		}
	}
}

//赋值符重载
CChiHuRight & CChiHuRight::operator = ( DWORD dwRight )
{
	DWORD dwOtherRight = 0;
	//验证权位
	if( !IsValidRight( dwRight ) )
	{
		//验证取反权位
		ASSERT( IsValidRight( ~dwRight ) );
		if( !IsValidRight( ~dwRight ) ) return *this;
		dwRight = ~dwRight;
		dwOtherRight = MASK_CHI_HU_RIGHT;
	}

	for( BYTE i = 0; i < CountArray(m_dwRightMask); i++ )
	{
		if( (dwRight&m_dwRightMask[i]) || (i==0&&dwRight<0x10000000) )
			m_dwRight[i] = dwRight&MASK_CHI_HU_RIGHT;
		else m_dwRight[i] = dwOtherRight;
	}

	return *this;
}

//与等于
CChiHuRight & CChiHuRight::operator &= ( DWORD dwRight )
{
	bool bNavigate = false;
	//验证权位
	if( !IsValidRight( dwRight ) )
	{
		//验证取反权位
		ASSERT( IsValidRight( ~dwRight ) );
		if( !IsValidRight( ~dwRight ) ) return *this;
		//调整权位
		DWORD dwHeadRight = (~dwRight)&0xF0000000;
		DWORD dwTailRight = dwRight&MASK_CHI_HU_RIGHT;
		dwRight = dwHeadRight|dwTailRight;
		bNavigate = true;
	}

	for( BYTE i = 0; i < CountArray(m_dwRightMask); i++ )
	{
		if( (dwRight&m_dwRightMask[i]) || (i==0&&dwRight<0x10000000) )
		{
			m_dwRight[i] &= (dwRight&MASK_CHI_HU_RIGHT);
		}
		else if( !bNavigate )
			m_dwRight[i] = 0;
	}

	return *this;
}

//或等于
CChiHuRight & CChiHuRight::operator |= ( DWORD dwRight )
{
	//验证权位
	if( !IsValidRight( dwRight ) ) return *this;

	for( BYTE i = 0; i < CountArray(m_dwRightMask); i++ )
	{
		if( (dwRight&m_dwRightMask[i]) || (i==0&&dwRight<0x10000000) )
			m_dwRight[i] |= (dwRight&MASK_CHI_HU_RIGHT);
	}

	return *this;
}

//与
CChiHuRight CChiHuRight::operator & ( DWORD dwRight )
{
	CChiHuRight chr = *this;
	return (chr &= dwRight);
}

//与
CChiHuRight CChiHuRight::operator & ( DWORD dwRight ) const
{
	CChiHuRight chr = *this;
	return (chr &= dwRight);
}

//或
CChiHuRight CChiHuRight::operator | ( DWORD dwRight )
{
	CChiHuRight chr = *this;
	return chr |= dwRight;
}

//或
CChiHuRight CChiHuRight::operator | ( DWORD dwRight ) const
{
	CChiHuRight chr = *this;
	return chr |= dwRight;
}

//是否权位为空
bool CChiHuRight::IsEmpty()
{
	for( BYTE i = 0; i < CountArray(m_dwRight); i++ )
		if( m_dwRight[i] ) return false;
	return true;
}

//设置权位为空
void CChiHuRight::SetEmpty()
{
	ZeroMemory( m_dwRight,sizeof(m_dwRight) );
	return;
}

//获取权位数值
BYTE CChiHuRight::GetRightData( DWORD dwRight[], BYTE cbMaxCount )
{
	ASSERT( cbMaxCount >= CountArray(m_dwRight) );
	if( cbMaxCount < CountArray(m_dwRight) ) return 0;

	CopyMemory( dwRight,m_dwRight,sizeof(DWORD)*CountArray(m_dwRight) );
	return CountArray(m_dwRight);
}

//设置权位数值
bool CChiHuRight::SetRightData( const DWORD dwRight[], BYTE cbRightCount )
{
	ASSERT( cbRightCount <= CountArray(m_dwRight) );
	if( cbRightCount > CountArray(m_dwRight) ) return false;

	ZeroMemory( m_dwRight,sizeof(m_dwRight) );
	CopyMemory( m_dwRight,dwRight,sizeof(DWORD)*cbRightCount );
	
	return true;
}

//检查仅位是否正确
bool CChiHuRight::IsValidRight( DWORD dwRight )
{
	DWORD dwRightHead = dwRight & 0xF0000000;
	for( BYTE i = 0; i < CountArray(m_dwRightMask); i++ )
		if( m_dwRightMask[i] == dwRightHead ) return true;
	return false;
}

//////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////
//静态变量

//扑克数据
const BYTE CGameLogic::m_cbCardDataArray[MAX_REPERTORY]=
{
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,						//万子
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,						//万子
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,						//万子
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,						//万子
	0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,						//索子
	0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,						//索子
	0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,						//索子
	0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,						//索子
	0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,						//同子
	0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,						//同子
	0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,						//同子
	0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,						//同子
};

//////////////////////////////////////////////////////////////////////////

//构造函数
CGameLogic::CGameLogic()
{
	m_cbMagicIndex = MAX_INDEX;
	m_cbGenCount = 0;
	m_bSingleMagic = true;
}

//析构函数
CGameLogic::~CGameLogic()
{
}

//混乱扑克
void CGameLogic::RandCardData(BYTE cbCardData[], BYTE cbMaxCount)
{
	//混乱准备
	BYTE cbCardDataTemp[CountArray(m_cbCardDataArray)];
	CopyMemory(cbCardDataTemp,m_cbCardDataArray,sizeof(m_cbCardDataArray));

	//混乱扑克
	BYTE cbRandCount=0,cbPosition=0;
	do
	{
		cbPosition=rand()%(cbMaxCount-cbRandCount);
		cbCardData[cbRandCount++]=cbCardDataTemp[cbPosition];
		cbCardDataTemp[cbPosition]=cbCardDataTemp[cbMaxCount-cbRandCount];
	} while (cbRandCount<cbMaxCount);

	return;
}

//删除扑克
bool CGameLogic::RemoveCard(BYTE cbCardIndex[MAX_INDEX], BYTE cbRemoveCard)
{
	//效验扑克
	ASSERT(IsValidCard(cbRemoveCard));
	ASSERT(cbCardIndex[SwitchToCardIndex(cbRemoveCard)]>0);

	//删除扑克
	BYTE cbRemoveIndex=SwitchToCardIndex(cbRemoveCard);
	if (cbCardIndex[cbRemoveIndex]>0)
	{
		cbCardIndex[cbRemoveIndex]--;
		return true;
	}

	//失败效验
	ASSERT(FALSE);

	return false;
}

//删除扑克
bool CGameLogic::RemoveCard(BYTE cbCardIndex[MAX_INDEX], const BYTE cbRemoveCard[], BYTE cbRemoveCount)
{
	//删除扑克
	for (BYTE i=0;i<cbRemoveCount;i++)
	{
		//效验扑克
		ASSERT(IsValidCard(cbRemoveCard[i]));
		ASSERT(cbCardIndex[SwitchToCardIndex(cbRemoveCard[i])]>0);

		//删除扑克
		BYTE cbRemoveIndex=SwitchToCardIndex(cbRemoveCard[i]);
		if (cbCardIndex[cbRemoveIndex]==0)
		{
			//错误断言
			ASSERT(FALSE);

			//还原删除
			for (BYTE j=0;j<i;j++) 
			{
				ASSERT(IsValidCard(cbRemoveCard[j]));
				cbCardIndex[SwitchToCardIndex(cbRemoveCard[j])]++;
			}

			return false;
		}
		else 
		{
			//删除扑克
			--cbCardIndex[cbRemoveIndex];
		}
	}

	return true;
}
 
// 判断是有无听用
bool CGameLogic::HaveMagicCard(const BYTE cbCardIndex[MAX_INDEX],const tagWeaveItem WeaveItem[], BYTE cbWeaveCount)
{
		for (BYTE i = 0;i<MAX_INDEX;i++)
		{

			if (cbCardIndex[i]>0 && IsMagicCard(SwitchToCardData(i)))
			{
				return true;
			}
		}

		for (BYTE i = 0;i<cbWeaveCount;i++)
		{
			if (WeaveItem[i].cbWeaveKind&WIK_TIE_PAI)
			{
				return true;
			}
		}

		return false;

}
// 判断是否有3个牌精
bool CGameLogic::HaveThreePaiJin(const BYTE cbCardIndex[MAX_INDEX],const tagWeaveItem WeaveItem[], BYTE cbWeaveCount)
{
	BYTE cbPaiJinCount = 0;
	for (BYTE k =0;k<cbWeaveCount;k++)
	{
		if(WeaveItem[k].cbCenterCard != m_PaiJing)
			continue;
		if (WeaveItem[k].cbWeaveKind&WIK_PENG || WeaveItem[k].cbWeaveKind&WIK_TIE_PAI)
		{
			cbPaiJinCount = 3;
			break;
		}
	}
	
	BYTE cbPaiJingIndex = SwitchToCardIndex(m_PaiJing);// 牌精索引
	cbPaiJinCount+=cbCardIndex[cbPaiJingIndex];

	return cbPaiJinCount >= 3;
	
}

void CGameLogic::SetPaiJing(BYTE cbCardData)
{

	if(!IsValidCard(cbCardData)) return;

	// 设置牌精
	m_PaiJing = cbCardData; 
	BYTE cbColor = m_PaiJing&MASK_COLOR;
	BYTE cbValue = m_PaiJing&MASK_VALUE;
	cbValue = cbValue%9+1;
	BYTE cbTingYong = (cbColor | cbValue);

	// 设置听用索引
	if (m_bSingleMagic)
	{
		m_cbMagicIndex = SwitchToCardIndex(cbTingYong);	
 	}else
	{
		//TODO: 实现双精判断
	}

 }


 
//删除扑克
bool CGameLogic::RemoveCard(BYTE cbCardData[], BYTE cbCardCount, const BYTE cbRemoveCard[], BYTE cbRemoveCount)
{
	//检验数据
	ASSERT(cbCardCount<=14);
	ASSERT(cbRemoveCount<=cbCardCount);

	//定义变量
	BYTE cbDeleteCount=0,cbTempCardData[14];
	if (cbCardCount>CountArray(cbTempCardData))
		return false;
	CopyMemory(cbTempCardData,cbCardData,cbCardCount*sizeof(cbCardData[0]));

	//置零扑克
	for (BYTE i=0;i<cbRemoveCount;i++)
	{
		for (BYTE j=0;j<cbCardCount;j++)
		{
			if (cbRemoveCard[i]==cbTempCardData[j])
			{
				cbDeleteCount++;
				cbTempCardData[j]=0;
				break;
			}
		}
	}

	//成功判断
	if (cbDeleteCount!=cbRemoveCount) 
	{
		ASSERT(FALSE);
		return false;
	}

	//清理扑克
	BYTE cbCardPos=0;
	for (BYTE i=0;i<cbCardCount;i++)
	{
		if (cbTempCardData[i]!=0) 
			cbCardData[cbCardPos++]=cbTempCardData[i];
	}

	return true;
}

//有效判断
bool CGameLogic::IsValidCard(BYTE cbCardData)
{
	BYTE cbValue=(cbCardData&MASK_VALUE);
	BYTE cbColor=(cbCardData&MASK_COLOR)>>4;
	return (((cbValue>=1)&&(cbValue<=9)&&(cbColor<=2))||((cbValue>=1)&&(cbValue<=7)&&(cbColor==3)));
}

//扑克数目
BYTE CGameLogic::GetCardCount(const BYTE cbCardIndex[MAX_INDEX])
{
	//数目统计
	BYTE cbCardCount=0;
	for (BYTE i=0;i<MAX_INDEX;i++) 
		cbCardCount+=cbCardIndex[i];

	return cbCardCount;
}

//获取组合
BYTE CGameLogic::GetWeaveCard(BYTE cbWeaveKind, BYTE cbCenterCard, BYTE cbCardBuffer[4])
{
	//组合扑克
	switch (cbWeaveKind)
	{

	case WIK_TI_PAI:		//提牌操作
	    {
		    //设置变量
			cbCardBuffer[0]=cbCenterCard;
			cbCardBuffer[1]=cbCenterCard;
			cbCardBuffer[2]=cbCenterCard;
			return 3;
	    }

	case WIK_TIE_PAI:		//贴牌操作
		{
			//设置变量
			cbCardBuffer[0]=cbCenterCard;
			cbCardBuffer[1]=cbCenterCard;
			cbCardBuffer[2]=SwitchToCardData(m_cbMagicIndex); // 魔术牌
			return 3;
		}
 
	case WIK_PENG:		//碰牌操作
		{
			//设置变量
			cbCardBuffer[0]=cbCenterCard;
			cbCardBuffer[1]=cbCenterCard;
			cbCardBuffer[2]=cbCenterCard;

			return 3;
		}
	case WIK_GANG:		//杠牌操作
		{
			//设置变量
			cbCardBuffer[0]=cbCenterCard;
			cbCardBuffer[1]=cbCenterCard;
			cbCardBuffer[2]=cbCenterCard;
			cbCardBuffer[3]=cbCenterCard;

			return 4;
		}
	default:
		{
			ASSERT(FALSE);
		}
	}

	return 0;
}


//动作等级
BYTE CGameLogic::GetUserActionRank(BYTE cbUserAction)
{
	//胡牌等级
	if (cbUserAction&WIK_CHI_HU) { return 4+3; }
	//杠牌等级
	if (cbUserAction&WIK_GANG) { return 4+2; }
	//碰牌等级
	if (cbUserAction&WIK_PENG) { return 4+1; }
	//贴牌等级
	if (cbUserAction&WIK_TIE_PAI){	return 4; }
	
	return 0;
}

//胡牌等级
WORD CGameLogic::GetChiHuActionRank(const CChiHuRight & ChiHuRight)
{
	WORD wFanShu = 1; // 素番算 一番 

	if( !(ChiHuRight&CHR_TIAN_HU).IsEmpty() || !(ChiHuRight&CHR_DI_HU).IsEmpty() ) // 天胡或者地胡 最高番
	{
		return (WORD)m_lMaxScoreTimes;
	}

	//////////////////////////////////////////////////////////////////////////
	// 加三番计算

	if( !(ChiHuRight&CHR_QING_YI_SE).IsEmpty() ) // 清一色 3番
	{
		wFanShu += 2;// 一共是3番
	}

	// 大队子 或者 七小对 
	if( !(ChiHuRight&CHR_DA_DUI_ZI).IsEmpty() ||  !(ChiHuRight&CHR_QI_XIAO_DUI).IsEmpty() ) // 大对子 3番
	{
		wFanShu += 2;// 一共是3番
	}
	
   //////////////////////////////////////////////////////////////////////////
	// 加一番计算
	if( !(ChiHuRight&CHR_WITHOUT_TING_YONG).IsEmpty() ) //缺听用加 1番
	{
		wFanShu+=1;
	}

	if( !(ChiHuRight&CHR_WITH_THREE_PAI_JIN).IsEmpty() ) //3个牌精 加1番
	{
		wFanShu +=1;
	}

	// 大单吊和单吊炮不能同时出现
	if( !(ChiHuRight&CHR_DA_DAN_DIAO).IsEmpty() ||!(ChiHuRight&CHR_DA_DAN_DIAO_PAO).IsEmpty()) //大单吊 1番
	{
		wFanShu += 1;
	}
	

	// 抢杠和杠上炮，杠上花 不能同时出现
	if( !(ChiHuRight&CHR_GANG_SHANG_PAO).IsEmpty()|| 
		!(ChiHuRight&CHR_QIANG_GANG).IsEmpty() ||
		!(ChiHuRight&CHR_GANG_KAI).IsEmpty()) 
	{
		wFanShu += 1;
	}
	

	
	// 有根就加番,有几根就加几番
	if (!(ChiHuRight&CHR_GENG_COUNT_ONE).IsEmpty() )
	{
		wFanShu += 1;

	}else if (!(ChiHuRight&CHR_GENG_COUNT_TWO).IsEmpty() )
	{
		wFanShu += 2;

	}else if (!(ChiHuRight&CHR_GENG_COUNT_THREE).IsEmpty() )
	{
		wFanShu += 3;
		
	}else if (!(ChiHuRight&CHR_GENG_COUNT_FOUR).IsEmpty() )
	{
		wFanShu += 4;
		
	}
	

	if (!(ChiHuRight&CHR_SHU_FAN).IsEmpty() ) // 素番
	{
		wFanShu = 1;
	}

	
	if (wFanShu>m_lMaxScoreTimes)
	{
		wFanShu = (WORD)m_lMaxScoreTimes;
	}


	return wFanShu;
}

//吃牌判断
BYTE CGameLogic::EstimateEatCard(const BYTE cbCardIndex[MAX_INDEX], BYTE cbCurrentCard)
{
	//参数效验
	ASSERT(IsValidCard(cbCurrentCard));

	//过滤判断
	if ( cbCurrentCard>=0x31 || IsMagicCard(cbCurrentCard) ) 
		return WIK_NULL;

	//变量定义
	BYTE cbExcursion[3]={0,1,2};
	BYTE cbItemKind[3]={WIK_LEFT,WIK_CENTER,WIK_RIGHT};

	//吃牌判断
	BYTE cbEatKind=0,cbFirstIndex=0;
	BYTE cbCurrentIndex=SwitchToCardIndex(cbCurrentCard);
	for (BYTE i=0;i<CountArray(cbItemKind);i++)
	{
		BYTE cbValueIndex=cbCurrentIndex%9;
		if ((cbValueIndex>=cbExcursion[i])&&((cbValueIndex-cbExcursion[i])<=6))
		{
			//吃牌判断
			cbFirstIndex=cbCurrentIndex-cbExcursion[i];

			//吃牌不能包含有听用
			if( m_cbMagicIndex != MAX_INDEX &&
				m_cbMagicIndex >= cbFirstIndex && m_cbMagicIndex <= cbFirstIndex+2 ) continue;

			if ((cbCurrentIndex!=cbFirstIndex)&&(cbCardIndex[cbFirstIndex]==0))
				continue;
			if ((cbCurrentIndex!=(cbFirstIndex+1))&&(cbCardIndex[cbFirstIndex+1]==0))
				continue;
			if ((cbCurrentIndex!=(cbFirstIndex+2))&&(cbCardIndex[cbFirstIndex+2]==0))
				continue;

			//设置类型
			cbEatKind|=cbItemKind[i];
		}
	}

	return cbEatKind;
}

//提牌判断
BYTE CGameLogic::AnalyseTIPaiCard(const BYTE cbCardIndex[MAX_INDEX],const tagWeaveItem WeaveItem[], BYTE cbWeaveCount,tagTICardResult& TICardResult)
{
	BYTE ret = WIK_NULL;
		
	if (m_cbMagicIndex!=MAX_INDEX)
	{
		for (BYTE j = 0; j<cbWeaveCount;j++)
		{
			BYTE cbCenterCard = WeaveItem[j].cbCenterCard;
			BYTE cbWeaveKind =  WeaveItem[j].cbWeaveKind;
			
			if((WeaveItem[j].cbWeaveKind&WIK_TIE_PAI)!=0 && cbCardIndex[SwitchToCardIndex(cbCenterCard)]>=1)
			{
				// 组合类型是贴牌 ， 手上至少有一张牌是跟贴牌同花色
				ret |=  WIK_TI_PAI;
				TICardResult.cbCardData[TICardResult.cbCardCount++]= cbCenterCard;
			}
		}
	}


	return ret;

}

//贴牌判断
BYTE CGameLogic::EstimateTiePaiCard(const BYTE cbCardIndex[MAX_INDEX], BYTE cbCurrentCard)
{

	// 禁止贴听用牌

	//参数效验
	ASSERT(IsValidCard(cbCurrentCard));
	//过滤判断
	if ( IsMagicCard(cbCurrentCard) ) 
		return WIK_NULL;

	
	BYTE ret = WIK_NULL;
	
	if(cbCardIndex[SwitchToCardIndex(cbCurrentCard)]>=1 && m_cbMagicIndex !=MAX_INDEX &&cbCardIndex[m_cbMagicIndex]>=1)
	{
		// 至少有一张打出的牌，同时至少有一张听用牌
		ret |= WIK_TIE_PAI;
	}
	return ret;
	
}

//碰牌判断
BYTE CGameLogic::EstimatePengCard(const BYTE cbCardIndex[MAX_INDEX], BYTE cbCurrentCard)
{
	//参数效验
	ASSERT(IsValidCard(cbCurrentCard));
	//过滤判断
	if ( IsMagicCard(cbCurrentCard) ) 
		return WIK_NULL;

	//碰牌判断
	return (cbCardIndex[SwitchToCardIndex(cbCurrentCard)]>=2)?WIK_PENG:WIK_NULL;
}

//杠牌判断
BYTE CGameLogic::EstimateGangCard(const BYTE cbCardIndex[MAX_INDEX], BYTE cbCurrentCard)
{
	//参数效验
	ASSERT(IsValidCard(cbCurrentCard));
#if 1

	//杠牌判断
	return (cbCardIndex[SwitchToCardIndex(cbCurrentCard)]==3)?WIK_GANG:WIK_NULL;

#else
	//过滤判断
	if ( IsMagicCard(cbCurrentCard) ) // 当前牌是魔术牌
		return WIK_NULL;

	//杠牌判断
	return (cbCardIndex[SwitchToCardIndex(cbCurrentCard)]==3)?WIK_GANG:WIK_NULL;
#endif 
}

//杠牌分析
BYTE CGameLogic::AnalyseGangCard(const BYTE cbCardIndex[MAX_INDEX], const tagWeaveItem WeaveItem[], BYTE cbWeaveCount, tagGangCardResult & GangCardResult)
{
	//设置变量
	BYTE cbActionMask=WIK_NULL;
	ZeroMemory(&GangCardResult,sizeof(GangCardResult));

	//手上杠牌
	for (BYTE i=0;i<MAX_INDEX;i++)
	{

		if( i == m_cbMagicIndex ) continue; 

		if (cbCardIndex[i]==4)
		{
			cbActionMask|=WIK_GANG;
			GangCardResult.cbCardData[GangCardResult.cbCardCount++]=SwitchToCardData(i);
		}
	}

	//组合杠牌
	for (BYTE i=0;i<cbWeaveCount;i++)
	{
		if (WeaveItem[i].cbWeaveKind==WIK_PENG)
		{
			if (cbCardIndex[SwitchToCardIndex(WeaveItem[i].cbCenterCard)]==1)
			{
				cbActionMask|=WIK_GANG;
				GangCardResult.cbCardData[GangCardResult.cbCardCount++]=WeaveItem[i].cbCenterCard;
			}
		}
	}

	return cbActionMask;
}

//吃胡分析
BYTE CGameLogic::AnalyseChiHuCard(const BYTE cbCardIndex[MAX_INDEX], const tagWeaveItem WeaveItem[], BYTE cbWeaveCount, BYTE cbCurrentCard, CChiHuRight &ChiHuRight)
{

	//变量定义
	BYTE cbChiHuKind=WIK_NULL;
	CAnalyseItemArray AnalyseItemArray;

	//设置变量
	AnalyseItemArray.RemoveAll();
	ChiHuRight.SetEmpty();

	//构造扑克
	BYTE cbCardIndexTemp[MAX_INDEX];
	CopyMemory(cbCardIndexTemp,cbCardIndex,sizeof(cbCardIndexTemp));


	//构造扑克
	BYTE cbCardIndexTemp2[MAX_INDEX];
	ZeroMemory(cbCardIndexTemp2,sizeof(cbCardIndexTemp2));
	m_cbGenCount = 0;
	BYTE cbFanShu = 0;
	CChiHuRight tmpChiHuRight;
	

	//cbCurrentCard一定不为0			!!!!!!!!!
	ASSERT( cbCurrentCard != 0 );
	if( cbCurrentCard == 0 ) return WIK_NULL;

	/*
	//	特殊番型
	*/

	//七小对牌
	if( IsQiXiaoDui(cbCardIndex,WeaveItem,cbWeaveCount,cbCurrentCard) ) 
	{
		ChiHuRight |= CHR_QI_XIAO_DUI;
	}

	if( !ChiHuRight.IsEmpty() )
		cbChiHuKind = WIK_CHI_HU;

	//插入扑克
	if (cbCurrentCard!=0)
		cbCardIndexTemp[SwitchToCardIndex(cbCurrentCard)]++;

	//必须缺一门
	if( IsHuaZhu(cbCardIndexTemp,WeaveItem,cbWeaveCount) )
	{
		return WIK_NULL;
	}



	//胡牌分析
 if((ChiHuRight&CHR_QI_XIAO_DUI).IsEmpty())
 {
		//分析扑克
	AnalyseCard(cbCardIndexTemp,WeaveItem,cbWeaveCount,AnalyseItemArray);
	if (AnalyseItemArray.GetCount()>0)
	{
		cbChiHuKind = WIK_CHI_HU;
	
		//牌型分析
		for (INT_PTR i=0;i<AnalyseItemArray.GetCount();i++)
		{
			//变量定义
			tagAnalyseItem * pAnalyseItem=&AnalyseItemArray[i];


			ZeroMemory(cbCardIndexTemp2,sizeof(cbCardIndexTemp2));
			cbCardIndexTemp2[SwitchToCardIndex(pAnalyseItem->cbCardEye)] = 2;
			BYTE cbTmpFanShu = 0;
			tmpChiHuRight.SetEmpty();
			for (BYTE k =0;k<4;k++)
			{

				if (pAnalyseItem->cbWeaveKind[k] == WIK_LEFT)
				{
					BYTE cbTmpIndex =  SwitchToCardIndex(pAnalyseItem->cbCenterCard[k]);
					for (BYTE t = 0;t < 3;t ++)
					{
						cbCardIndexTemp2[cbTmpIndex]++;
						cbTmpIndex++;
					}
					
				}else if (pAnalyseItem->cbWeaveKind[k] == WIK_PENG || pAnalyseItem->cbWeaveKind[k] == WIK_TIE_PAI)
				{
					BYTE cbTmpIndex =  SwitchToCardIndex(pAnalyseItem->cbCenterCard[k]);
					for (BYTE t = 0;t < 3;t ++)
					{
						cbCardIndexTemp2[cbTmpIndex]++; 
					}
				}else if (pAnalyseItem->cbWeaveKind[k] == WIK_GANG)
				{
					BYTE cbTmpIndex =  SwitchToCardIndex(pAnalyseItem->cbCenterCard[k]);
					for (BYTE t = 0;t < 4;t ++)
					{
						cbCardIndexTemp2[cbTmpIndex]++; 
					}

				}

			}


	//  分析根
		BYTE tmpCount = 0;
		for (BYTE k = 0;k<MAX_INDEX;k++)
		{
			// 分析碰贴牌，在手上牌中查找是否有根
			if (cbCardIndexTemp2[k] == 4)
			{
				tmpCount++;
				cbTmpFanShu++;
			}
	
		}
	
		// 判断是否有3个牌精
		if (HaveThreePaiJin(cbCardIndexTemp2,WeaveItem,cbWeaveCount))
		{
			tmpChiHuRight |= CHR_WITH_THREE_PAI_JIN;
			cbTmpFanShu = (cbTmpFanShu == 0)?2:(cbTmpFanShu+=1);
			
		}


			/*
			//	判断番型
			*/
			//碰碰和
			if( IsPengPeng(pAnalyseItem) ) 
			{
				tmpChiHuRight |= CHR_DA_DUI_ZI;
				cbTmpFanShu+=3;
			}



			if(cbTmpFanShu>cbFanShu)
			{
				cbFanShu = cbTmpFanShu;
				DWORD wRightData =0;
				tmpChiHuRight.GetRightData(&wRightData, MAX_RIGHT_COUNT);
				ChiHuRight.SetRightData(&wRightData, MAX_RIGHT_COUNT);
				m_cbGenCount = tmpCount;

			}
	
#if 0

			//带幺
			if( IsDaiYao(pAnalyseItem) )
				ChiHuRight |= CHR_DAI_YAO;
			//将对
			if( IsJiangDui(pAnalyseItem) )
				ChiHuRight |= CHR_JIANG_DUI;
#endif 
		}
	}
 }
	


	if(!(ChiHuRight&CHR_QI_XIAO_DUI).IsEmpty())
	{
		BYTE cbTingYongCardCount = cbCardIndexTemp[m_cbMagicIndex];
		BYTE cbOneCount = 0,cbThreeCount = 0;

		ChiHuRight &=~CHR_DA_DUI_ZI;
		for(BYTE k = 0;k<MAX_INDEX-7;k++)
		{

			if( k == m_cbMagicIndex ) continue;

			if(cbCardIndexTemp[k] == 4)
			{
				m_cbGenCount++;
			}

			BYTE cbCardCount=cbCardIndexTemp[k];
			if(cbCardCount == 1)
			{
				cbOneCount++; 
			}else if(cbCardCount == 3)
			{
				cbThreeCount++; 
			}


		}


		switch (cbTingYongCardCount)
		{
		case 1:
			if (cbThreeCount == 1)
				m_cbGenCount++;
			break;
		case 2:
			if (cbThreeCount == 2 && cbOneCount == 0)
				m_cbGenCount+=2;
			else if (cbThreeCount == 1 && cbOneCount == 1)
				m_cbGenCount++;

			break;
		case 3:
			if (cbThreeCount == 1 && cbOneCount == 0)
				m_cbGenCount+=2;
			else if (cbThreeCount == 3 && cbOneCount == 0)
				m_cbGenCount+=cbThreeCount;
			else if ( cbThreeCount == 2 && cbOneCount == 1)
				m_cbGenCount+=cbThreeCount;
			else if (cbThreeCount == 1 && cbOneCount == 2)
				m_cbGenCount+=cbThreeCount;

			break;
		case 4:
			if (cbThreeCount == 2 && cbOneCount == 0)
 				m_cbGenCount+=3;
			else if (cbThreeCount == 1 && cbOneCount == 1)
				m_cbGenCount+=2;
			else if ( cbThreeCount == 2 && cbOneCount == 2)
				m_cbGenCount+=cbThreeCount;
			else if (cbThreeCount == 1 && cbOneCount == 3)
				m_cbGenCount+=cbThreeCount;

			break;
		default:
			break;
		}

	}
	

	if( cbChiHuKind == WIK_CHI_HU )
	{
		//清一色牌
		if( IsQingYiSe(cbCardIndex,WeaveItem,cbWeaveCount,cbCurrentCard) )
		{
			ChiHuRight |= CHR_QING_YI_SE;
		}

		if (!HaveMagicCard(cbCardIndex,WeaveItem,cbWeaveCount) && IsMagicCard(cbCurrentCard)==false) // 缺听用
		{
			ChiHuRight |= CHR_WITHOUT_TING_YONG;

		}

		if (IsDaDanDiao(cbCardIndex,cbWeaveCount)) // 大单吊
  	    {
			ChiHuRight |= CHR_DA_DAN_DIAO;
		}



		switch(m_cbGenCount)
		{
			case 1:
				ChiHuRight|= CHR_GENG_COUNT_ONE;
				break;
			case 2:
				ChiHuRight|= CHR_GENG_COUNT_TWO;
				break;
			case 3:
				ChiHuRight|= CHR_GENG_COUNT_THREE;
				break;
			case 4:
				ChiHuRight|= CHR_GENG_COUNT_FOUR;
				break;
						
		}

		//素番
		if( cbChiHuKind == WIK_CHI_HU && ChiHuRight.IsEmpty() )
			ChiHuRight |= CHR_SHU_FAN;

	}

	return cbChiHuKind;
}

//是否听牌
bool CGameLogic::IsTingCard( const BYTE cbCardIndex[MAX_INDEX], const tagWeaveItem WeaveItem[], BYTE cbWeaveCount )
{
	//复制数据
	BYTE cbCardIndexTemp[MAX_INDEX];
	CopyMemory( cbCardIndexTemp,cbCardIndex,sizeof(cbCardIndexTemp) );

	CChiHuRight chr;
	for( BYTE i = 0; i < MAX_INDEX-7; i++ )
	{
		BYTE cbCurrentCard = SwitchToCardData( i );
		if( WIK_CHI_HU == AnalyseChiHuCard( cbCardIndexTemp,WeaveItem,cbWeaveCount,cbCurrentCard,chr ) )
			return true;
	}
	return false;
}

//扑克转换
BYTE CGameLogic::SwitchToCardData(BYTE cbCardIndex)
{
	ASSERT(cbCardIndex<34);
	return ((cbCardIndex/9)<<4)|(cbCardIndex%9+1);
}

//扑克转换
BYTE CGameLogic::SwitchToCardIndex(BYTE cbCardData)
{
	ASSERT(IsValidCard(cbCardData));
	return ((cbCardData&MASK_COLOR)>>4)*9+(cbCardData&MASK_VALUE)-1;
}

//扑克转换
BYTE CGameLogic::SwitchToCardData(const BYTE cbCardIndex[MAX_INDEX], BYTE cbCardData[MAX_COUNT])
{
	//转换扑克
	BYTE cbPosition=0;
	//钻牌
	if( m_cbMagicIndex != MAX_INDEX )
	{
		for( BYTE i = 0; i < cbCardIndex[m_cbMagicIndex]; i++ )
			cbCardData[cbPosition++] = SwitchToCardData(m_cbMagicIndex);
	}
	for (BYTE i=0;i<MAX_INDEX;i++)
	{
		if( i == m_cbMagicIndex ) continue; //听用已转换，转换剩余牌，总数不变
		if (cbCardIndex[i]!=0)
		{
			for (BYTE j=0;j<cbCardIndex[i];j++)
			{
				ASSERT(cbPosition<MAX_COUNT);
				cbCardData[cbPosition++]=SwitchToCardData(i);
			}
		}
	}

	return cbPosition;
}

//扑克转换
BYTE CGameLogic::SwitchToCardIndex(const BYTE cbCardData[], BYTE cbCardCount, BYTE cbCardIndex[MAX_INDEX])
{
	//设置变量
	ZeroMemory(cbCardIndex,sizeof(BYTE)*MAX_INDEX);

	//转换扑克
	for (BYTE i=0;i<cbCardCount;i++)
	{
		ASSERT(IsValidCard(cbCardData[i]));
		if (!IsValidCard(cbCardData[i])) continue;
		cbCardIndex[SwitchToCardIndex(cbCardData[i])]++;
	}

	return cbCardCount;
}

//分析扑克
bool CGameLogic::AnalyseCard(const BYTE cbCardIndex[MAX_INDEX], const tagWeaveItem WeaveItem[], BYTE cbWeaveCount, CAnalyseItemArray & AnalyseItemArray)
{
	//计算数目
	BYTE cbCardCount=GetCardCount(cbCardIndex);

	//效验数目
	ASSERT((cbCardCount>=2)&&(cbCardCount<=MAX_COUNT)&&((cbCardCount-2)%3==0));
	if ((cbCardCount<2)||(cbCardCount>MAX_COUNT)||((cbCardCount-2)%3!=0))
	{
		return false;
	}
	//变量定义
	BYTE cbKindItemCount=0;
#if 1 
	tagKindItem KindItem[220]; //  最大组合12选3 = 12!/(9!*3!) = 220
#else
	tagKindItem KindItem[27*2+7+14];
#endif 
	ZeroMemory(KindItem,sizeof(KindItem));

	//需求判断
	BYTE cbLessKindItem=(cbCardCount-2)/3;
	ASSERT((cbLessKindItem+cbWeaveCount)==4);
	
	//单吊判断
	if (cbLessKindItem==0)
	{
		//效验参数
		ASSERT((cbCardCount==2)&&(cbWeaveCount==4));

		//牌眼判断
		for (BYTE i=0;i<MAX_INDEX;i++)
		{
			if (cbCardIndex[i]==2 || 
				( m_cbMagicIndex != MAX_INDEX && i != m_cbMagicIndex && cbCardIndex[m_cbMagicIndex]+cbCardIndex[i]==2 ) )
			{
				//变量定义
				tagAnalyseItem AnalyseItem;
				ZeroMemory(&AnalyseItem,sizeof(AnalyseItem));

				//设置结果
				for (BYTE j=0;j<cbWeaveCount;j++)
				{
					AnalyseItem.cbWeaveKind[j]=WeaveItem[j].cbWeaveKind;
					AnalyseItem.cbCenterCard[j]=WeaveItem[j].cbCenterCard;
					GetWeaveCard( WeaveItem[j].cbWeaveKind,WeaveItem[j].cbCenterCard,AnalyseItem.cbCardData[j] );
				}
				AnalyseItem.cbCardEye=SwitchToCardData(i);
				if( cbCardIndex[i] < 2 || i == m_cbMagicIndex )
					AnalyseItem.bMagicEye = true;
				else AnalyseItem.bMagicEye = false;

				//插入结果
				AnalyseItemArray.Add(AnalyseItem);

				return true;
			}
		}

		return false;
	}

	//拆分分析
	BYTE cbMagicCardIndex[MAX_INDEX];
	CopyMemory(cbMagicCardIndex,cbCardIndex,sizeof(cbMagicCardIndex));
	BYTE cbMagicCardCount = 0;
	if( m_cbMagicIndex != MAX_INDEX )
	{
		cbMagicCardCount = cbCardIndex[m_cbMagicIndex];
		if( cbMagicCardIndex[m_cbMagicIndex] ) cbMagicCardIndex[m_cbMagicIndex] = 1;		//减小多余组合
	}
	if (cbCardCount>=3)
	{
		for (BYTE i=0;i<MAX_INDEX;i++)
		{
			//同牌判断
			if (cbMagicCardIndex[i]+cbMagicCardCount>=3)
			{
				ASSERT( cbKindItemCount < CountArray(KindItem) );
				KindItem[cbKindItemCount].cbCardIndex[0]=i;
				KindItem[cbKindItemCount].cbCardIndex[1]=i;
				KindItem[cbKindItemCount].cbCardIndex[2]=i;
				KindItem[cbKindItemCount].cbWeaveKind=WIK_PENG;
				KindItem[cbKindItemCount].cbCenterCard=SwitchToCardData(i);
				KindItem[cbKindItemCount].cbValidIndex[0] = cbMagicCardIndex[i]>0?i:m_cbMagicIndex;
				KindItem[cbKindItemCount].cbValidIndex[1] = cbMagicCardIndex[i]>1?i:m_cbMagicIndex;
				KindItem[cbKindItemCount].cbValidIndex[2] = cbMagicCardIndex[i]>2?i:m_cbMagicIndex;
				cbKindItemCount++;
				if(cbMagicCardIndex[i]+cbMagicCardCount>=6) // 如果可以分析为2个碰组
				{
					ASSERT( cbKindItemCount < CountArray(KindItem) ); // 第2组
					KindItem[cbKindItemCount].cbCardIndex[0]=i;
					KindItem[cbKindItemCount].cbCardIndex[1]=i;
					KindItem[cbKindItemCount].cbCardIndex[2]=i;
					KindItem[cbKindItemCount].cbWeaveKind=WIK_PENG;
					KindItem[cbKindItemCount].cbCenterCard=SwitchToCardData(i);
					KindItem[cbKindItemCount].cbValidIndex[0] = cbMagicCardIndex[i]>3?i:m_cbMagicIndex;
					KindItem[cbKindItemCount].cbValidIndex[1] = m_cbMagicIndex;
					KindItem[cbKindItemCount].cbValidIndex[2] = m_cbMagicIndex;
					cbKindItemCount++;
				}
			}

			//连牌判断
			if ((i<(MAX_INDEX-9))&&((i%9)<7))
			{
				//只要财神牌数加上3个顺序索引的牌数大于等于3,则进行组合
				if( cbMagicCardCount+cbMagicCardIndex[i]+cbMagicCardIndex[i+1]+cbMagicCardIndex[i+2] >= 3 )
				{
					BYTE cbIndex[3] = { i==m_cbMagicIndex?0:cbMagicCardIndex[i],(i+1)==m_cbMagicIndex?0:cbMagicCardIndex[i+1],
						(i+2)==m_cbMagicIndex?0:cbMagicCardIndex[i+2] };
					int nMagicCountTemp = cbMagicCardCount;
					BYTE cbValidIndex[3];
					while( nMagicCountTemp+cbIndex[0]+cbIndex[1]+cbIndex[2] >= 3 )
					{
						for( BYTE j = 0; j < CountArray(cbIndex); j++ )
						{
							if( cbIndex[j] > 0 ) 
							{
								cbIndex[j]--;
								cbValidIndex[j] = i+j;
							}
							else 
							{
								nMagicCountTemp--;
								cbValidIndex[j] = m_cbMagicIndex;
							}
						}
					
						if( nMagicCountTemp >= 0 )
						{
							ASSERT( cbKindItemCount < CountArray(KindItem) );
							KindItem[cbKindItemCount].cbCardIndex[0]=i;
							KindItem[cbKindItemCount].cbCardIndex[1]=i+1;
							KindItem[cbKindItemCount].cbCardIndex[2]=i+2;
							KindItem[cbKindItemCount].cbWeaveKind=WIK_LEFT;
							KindItem[cbKindItemCount].cbCenterCard=SwitchToCardData(i);
							CopyMemory( KindItem[cbKindItemCount].cbValidIndex,cbValidIndex,sizeof(cbValidIndex) );
							cbKindItemCount++;
						}
						else break;
					}

					if (cbMagicCardIndex[i]>=1 && cbMagicCardIndex[i+1]>=1&&cbMagicCardCount>0)
					{

						cbValidIndex[0] = i;cbValidIndex[1] = i+1;cbValidIndex[2] = m_cbMagicIndex;
						ASSERT( cbKindItemCount < CountArray(KindItem) );
						KindItem[cbKindItemCount].cbCardIndex[0]=i;
						KindItem[cbKindItemCount].cbCardIndex[1]=i+1;
						KindItem[cbKindItemCount].cbCardIndex[2]=i+2;
						KindItem[cbKindItemCount].cbWeaveKind=WIK_LEFT;
						KindItem[cbKindItemCount].cbCenterCard=SwitchToCardData(i);
						CopyMemory( KindItem[cbKindItemCount].cbValidIndex,cbValidIndex,sizeof(cbValidIndex) );
						cbKindItemCount++;

					}
					if (cbMagicCardIndex[i+1]>=1 && cbMagicCardIndex[i+2]>=1&&cbMagicCardCount>0)
					{
						cbValidIndex[0] = m_cbMagicIndex;cbValidIndex[1] = i+1;cbValidIndex[2] = i+2;
						ASSERT( cbKindItemCount < CountArray(KindItem) );
						KindItem[cbKindItemCount].cbCardIndex[0]=i;
						KindItem[cbKindItemCount].cbCardIndex[1]=i+1;
						KindItem[cbKindItemCount].cbCardIndex[2]=i+2;
						KindItem[cbKindItemCount].cbWeaveKind=WIK_LEFT;
						KindItem[cbKindItemCount].cbCenterCard=SwitchToCardData(i);
						CopyMemory( KindItem[cbKindItemCount].cbValidIndex,cbValidIndex,sizeof(cbValidIndex) );
						cbKindItemCount++;

					}
					if (cbMagicCardIndex[i]>=1 && cbMagicCardIndex[i+2]>=1&&cbMagicCardCount>0)
					{
						cbValidIndex[0] = i;cbValidIndex[1] = m_cbMagicIndex;cbValidIndex[2] = i+2;
						ASSERT( cbKindItemCount < CountArray(KindItem) );
						KindItem[cbKindItemCount].cbCardIndex[0]=i;
						KindItem[cbKindItemCount].cbCardIndex[1]=i+1;
						KindItem[cbKindItemCount].cbCardIndex[2]=i+2;
						KindItem[cbKindItemCount].cbWeaveKind=WIK_LEFT;
						KindItem[cbKindItemCount].cbCenterCard=SwitchToCardData(i);
						CopyMemory( KindItem[cbKindItemCount].cbValidIndex,cbValidIndex,sizeof(cbValidIndex) );
						cbKindItemCount++;

					}

				}
			}
		}
	}


	//组合分析
	if (cbKindItemCount>=cbLessKindItem)
	{
		//变量定义
		BYTE cbCardIndexTemp[MAX_INDEX];
		ZeroMemory(cbCardIndexTemp,sizeof(cbCardIndexTemp));

		//变量定义
		BYTE cbIndex[4]={0,1,2,3};
		tagKindItem * pKindItem[4];
		ZeroMemory(&pKindItem,sizeof(pKindItem));

		//开始组合
		do
		{
			//设置变量
			CopyMemory(cbCardIndexTemp,cbCardIndex,sizeof(cbCardIndexTemp));
			for (BYTE i=0;i<cbLessKindItem;i++)
				pKindItem[i]=&KindItem[cbIndex[i]];

			//数量判断
			bool bEnoughCard=true;
			for (BYTE i=0;i<cbLessKindItem*3;i++)
			{
				//存在判断
				BYTE cbCardIndex=pKindItem[i/3]->cbValidIndex[i%3]; 
				if (cbCardIndexTemp[cbCardIndex]==0)
				{
					bEnoughCard=false;
					break;
				}
				else 
					cbCardIndexTemp[cbCardIndex]--;
			}

			//胡牌判断
			if (bEnoughCard==true)
			{
				//牌眼判断
				BYTE cbCardEye=0;
				bool bMagicEye = false;
				for (BYTE i=0;i<MAX_INDEX;i++)
				{
					if (cbCardIndexTemp[i]==2)
					{
						cbCardEye=SwitchToCardData(i);
						if( i == m_cbMagicIndex ) bMagicEye = true;
						break;
					}
					else if( i!=m_cbMagicIndex && 
						m_cbMagicIndex != MAX_INDEX && cbCardIndexTemp[i]+cbCardIndexTemp[m_cbMagicIndex]==2 )
					{
						cbCardEye = SwitchToCardData(i);
						bMagicEye = true;
					}
				}

				//组合类型
				if (cbCardEye!=0)
				{
					//变量定义
					tagAnalyseItem AnalyseItem;
					ZeroMemory(&AnalyseItem,sizeof(AnalyseItem));

					//设置组合
					for (BYTE i=0;i<cbWeaveCount;i++)
					{
						AnalyseItem.cbWeaveKind[i]=WeaveItem[i].cbWeaveKind;
						AnalyseItem.cbCenterCard[i]=WeaveItem[i].cbCenterCard;
						GetWeaveCard( WeaveItem[i].cbWeaveKind,WeaveItem[i].cbCenterCard,
							AnalyseItem.cbCardData[i] );
					}

					//设置牌型
					for (BYTE i=0;i<cbLessKindItem;i++) 
					{
						AnalyseItem.cbWeaveKind[i+cbWeaveCount]=pKindItem[i]->cbWeaveKind;
						AnalyseItem.cbCenterCard[i+cbWeaveCount]=pKindItem[i]->cbCenterCard;
						AnalyseItem.cbCardData[cbWeaveCount+i][0] = SwitchToCardData(pKindItem[i]->cbValidIndex[0]);
						AnalyseItem.cbCardData[cbWeaveCount+i][1] = SwitchToCardData(pKindItem[i]->cbValidIndex[1]);
						AnalyseItem.cbCardData[cbWeaveCount+i][2] = SwitchToCardData(pKindItem[i]->cbValidIndex[2]);
					}

					//设置牌眼
					AnalyseItem.cbCardEye=cbCardEye;
					AnalyseItem.bMagicEye = bMagicEye;

					//插入结果
					AnalyseItemArray.Add(AnalyseItem);
				}
			}

			//设置索引
			if (cbIndex[cbLessKindItem-1]==(cbKindItemCount-1))
			{
				BYTE i = 0;
				for (i=cbLessKindItem-1;i>0;i--)
				{
					if ((cbIndex[i-1]+1)!=cbIndex[i])
					{
						BYTE cbNewIndex=cbIndex[i-1];
						for (BYTE j=(i-1);j<cbLessKindItem;j++) 
							cbIndex[j]=cbNewIndex+j-i+2;
						break;
					}
				}
				if (i==0)
					break;
			}
			else
				cbIndex[cbLessKindItem-1]++;
		} while (true);

	}

	return (AnalyseItemArray.GetCount()>0);
}

//钻牌
bool CGameLogic::IsMagicCard( BYTE cbCardData )
{
	if(IsValidCard(cbCardData))
	{
		BYTE cbColor = m_PaiJing&MASK_COLOR;
		BYTE cbValue = m_PaiJing&MASK_VALUE;

		if (m_bSingleMagic)
		{
			cbValue = cbValue%9+1;
			BYTE cbTingYong = (cbColor | cbValue);

			return cbCardData == cbTingYong ? true:false;
		}else
		{
			//TODO: 实现双精判断
		
		}
	}

	return false;
}

//排序,根据牌值排序
bool CGameLogic::SortCardList( BYTE cbCardData[MAX_COUNT], BYTE cbCardCount )
{
	//数目过虑
	if (cbCardCount==0||cbCardCount>MAX_COUNT) return false;

	//排序操作
	bool bSorted=true;
	BYTE cbSwitchData=0,cbLast=cbCardCount-1;
	do
	{
		bSorted=true;
		for (BYTE i=0;i<cbLast;i++)
		{
			if (cbCardData[i]>cbCardData[i+1])
			{
				//设置标志
				bSorted=false;

				//扑克数据
				cbSwitchData=cbCardData[i];
				cbCardData[i]=cbCardData[i+1];
				cbCardData[i+1]=cbSwitchData;
			}	
		}
		cbLast--;
	} while(bSorted==false);

	return true;
}

/*
// 胡法分析函数
*/

//大对子
bool CGameLogic::IsPengPeng( const tagAnalyseItem *pAnalyseItem )
{
	for( BYTE i = 0; i < CountArray(pAnalyseItem->cbWeaveKind); i++ )
	{
		if( (pAnalyseItem->cbWeaveKind[i]&WIK_LEFT)!=0)
			return false;
	}
	return true;
}

//清一色牌
bool CGameLogic::IsQingYiSe(const BYTE cbCardIndex[MAX_INDEX], const tagWeaveItem WeaveItem[], const BYTE cbItemCount,const BYTE cbCurrentCard)
{
	//胡牌判断
	BYTE cbCardColor=0xFF;

	for (BYTE i=0;i<MAX_INDEX;i++)
	{
		if(i==m_cbMagicIndex) continue;
		if (cbCardIndex[i]!=0)
		{
			//花色判断
			if (cbCardColor!=0xFF)
				return false;

			//设置花色
			cbCardColor=(SwitchToCardData(i)&MASK_COLOR);

			//设置索引
			i=(i/9+1)*9-1;
		}
	}

	//如果手上只有王霸
	if( cbCardColor == 0xFF )
	{
		ASSERT( m_cbMagicIndex != MAX_INDEX && cbCardIndex[m_cbMagicIndex] > 0 );
		//检查组合
		ASSERT( cbItemCount > 0 );
		cbCardColor = WeaveItem[0].cbCenterCard&MASK_COLOR;
	}

	if((cbCurrentCard&MASK_COLOR)!=cbCardColor && !IsMagicCard(cbCurrentCard) ) return false;

	//组合判断
	for (BYTE i=0;i<cbItemCount;i++)
	{
		BYTE cbCenterCard=WeaveItem[i].cbCenterCard;
		if ((cbCenterCard&MASK_COLOR)!=cbCardColor)	return false;
	}

	return true;
}

//七小对牌
bool CGameLogic::IsQiXiaoDui(const BYTE cbCardIndex[MAX_INDEX], const tagWeaveItem WeaveItem[], const BYTE cbWeaveCount,const BYTE cbCurrentCard)
{
	//组合判断
	if (cbWeaveCount!=0) return false;

	//单牌数目
	BYTE cbReplaceCount = 0;

	//临时数据
	BYTE cbCardIndexTemp[MAX_INDEX];
	CopyMemory(cbCardIndexTemp,cbCardIndex,sizeof(cbCardIndexTemp));

	//插入数据
	BYTE cbCurrentIndex = SwitchToCardIndex(cbCurrentCard);
	cbCardIndexTemp[cbCurrentIndex]++;

	//计算单牌
	for (BYTE i=0;i<MAX_INDEX;i++)
	{
		BYTE cbCardCount=cbCardIndexTemp[i];

		//王牌过滤
		if( i == m_cbMagicIndex ) continue;

		//单牌统计
		if( cbCardCount == 1 || cbCardCount == 3 ) 	cbReplaceCount++;
	}

	//王牌不够
	if( m_cbMagicIndex != MAX_INDEX && cbReplaceCount > cbCardIndexTemp[m_cbMagicIndex] ||
		m_cbMagicIndex == MAX_INDEX && cbReplaceCount > 0 )
		return false;

	return true;

}

//带幺
bool CGameLogic::IsDaiYao( const tagAnalyseItem *pAnalyseItem )
{
	//检查牌眼
	BYTE cbCardValue = pAnalyseItem->cbCardEye&MASK_VALUE;
	if( cbCardValue != 1 && cbCardValue != 9 ) return false;

	for( BYTE i = 0; i < CountArray(pAnalyseItem->cbWeaveKind); i++ )
	{
		if( pAnalyseItem->cbWeaveKind[i]&(WIK_LEFT|WIK_CENTER|WIK_RIGHT) )
		{
			BYTE j = 0;
			for(j = 0; j < 3; j++ )
			{
				cbCardValue = pAnalyseItem->cbCardData[i][j]&MASK_VALUE;
				if( cbCardValue == 1 || cbCardValue == 9 ) break;
			}
			if( j == 3 ) return false;
		}
		else
		{
			cbCardValue = pAnalyseItem->cbCenterCard[i]&MASK_VALUE;
			if( cbCardValue != 1 && cbCardValue != 9 ) return false;
		}
	}
	return true;
}

//将对 //就是 碰的牌 和 胡的牌 必须是二，五，八的牌就叫将对
bool CGameLogic::IsJiangDui( const tagAnalyseItem *pAnalyseItem )
{
	//是否大对子
	if( !IsPengPeng(pAnalyseItem) ) return false;

	//检查牌眼
	BYTE cbCardValue = pAnalyseItem->cbCardEye&MASK_VALUE;
	if( cbCardValue != 2 && cbCardValue != 5 && cbCardValue != 8 ) return false;

	for( BYTE i = 0; i < CountArray(pAnalyseItem->cbWeaveKind); i++ )
	{
		if( pAnalyseItem->cbWeaveKind[i]&(WIK_LEFT|WIK_CENTER|WIK_RIGHT) )
		{
			BYTE j = 0;
			for( j = 0; j < 3; j++ )
			{
				cbCardValue = pAnalyseItem->cbCardData[i][j]&MASK_VALUE;
				if( cbCardValue == 2 || cbCardValue == 5 || cbCardValue == 8 ) break;
			}
			if( j == 3 ) return false;
		}
		else
		{
			cbCardValue = pAnalyseItem->cbCenterCard[i]&MASK_VALUE;
			if( cbCardValue != 2 && cbCardValue != 5 && cbCardValue != 8 ) return false;
		}
	}
	return true;
}

//是否花猪
bool CGameLogic::IsHuaZhu( const BYTE cbCardIndex[], const tagWeaveItem WeaveItem[], BYTE cbWeaveCount )
{
	BYTE cbColor[3] = { 0,0,0 };
	for( BYTE i = 0; i < MAX_INDEX; i++ )
	{

		if (m_cbMagicIndex == i)
		{
			continue; // oma 跳过听用
		}
 
		if( cbCardIndex[i] > 0 )
		{
			BYTE cbCardColor = SwitchToCardData(i)&MASK_COLOR;
			cbColor[cbCardColor>>4]++;

			i = (i/9+1)*9-1;
		}
	}
	for( BYTE i = 0; i < cbWeaveCount; i++ )
	{
		BYTE cbCardColor = WeaveItem[i].cbCenterCard&MASK_COLOR;
		cbColor[cbCardColor>>4]++;
	}
	//缺一门就不是花猪
	for( BYTE i = 0; i < CountArray(cbColor); i++ )
		if( cbColor[i] == 0 ) return false;

	return true;
}

 
bool CGameLogic::IsDaDanDiao(const BYTE cbCardIndex[MAX_INDEX],const BYTE cbWeaveCount)
{
	return (GetCardCount(cbCardIndex) == 1 && cbWeaveCount == 4);
}
 


 //////////////////////////////////////////////////////////////////////////
